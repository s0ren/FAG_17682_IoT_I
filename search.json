[
  {
    "objectID": "Features/Oled.html",
    "href": "Features/Oled.html",
    "title": "Oled display",
    "section": "",
    "text": "Video\nvideo demo\n\n\n\n\nTEC har nogle billige “kompatible” OLED displays som er nogenlunde kompatible med AdaFruits tilsvarende. Vi har fået fat i nogen fra producenten DIYmore.\n\nAdaFruits produkt og endnu en udgave af SSD1306\nDe kan altså bruge driverne, som AdaFruit har udviklet til SSD1306, til denne hardware også.\nAdaFruits driver til SSD1306 findes her\nMan kan kigge lidt til Random Nerd Tutorials ESP32 OLED Display with Arduino IDE, som har en vejledning til ESP32, dog med Arduino framework og et 128x64 pixels display.\nMens forbindelserne er næsten de samme. har jeg dog haft hæld med nogle andre pins. Desuden er vores displays 128x32 pixels.\n\n\n\n\nFor at bruge OLED displayet sammen med nanoFramework og C#, kan vi bruge device-driveren dss13xx, og dette kode eksemplet. For at bekræfte at det virker, har jeg implementeret og afprøvet med … som er i mit egent git repo på GitHub.\nDet der mangler, i de officielle vejledninger er en konkret opstilling, og et billede eller digram af hvor dan det hele forbindes. Man kan let blive i tvivl om hvor mange ben der “bør” være på displayet, og hvor de skal tilsluttes. Det gør at der er mange valg og dermed fejl muligheder.\n\n\n\n\n\n\n\n\nfrizing med OLED\n\n\n\nTilslutninger\n\n\nESP32-DEVKIT-V1\nOLED display\n\n\n\n\n\nSDA\nD21\nData\n\n\nSCL\nD22\nClock\n\n\nVCC\n3v3\nForsyningsspænding (3,3V)\n\n\nGND\nGND\nJord, stel, nul, minus etc\n\n\n\nJeg vælger at følge kodeeksemplet, og sætte Data og Clock til hhv. D21 og D22. Hvis man kigger på Michanti’s ESP32-DOIT-DEV-KIT-V1, kan man se at port 21 og 22 er markeret lyssebly felter, hvor der står hhv. [SDA] og [SCL]. Desværre stemmer det ikke godt overens med tabellen i nanoFrameworks “ESP32 pinout”?\n\n\n\nMed Project -&gt; Manage Nuget Packages kan du sørge for at det nødvendige pakker er til stede. Du kan også se pakkerne og ders oprindelse i filen packages.config:\n&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;\n&lt;packages&gt;\n  &lt;package id=\"nanoFramework.CoreLibrary\" version=\"1.17.11\" targetFramework=\"netnano1.0\" /&gt;\n  &lt;package id=\"nanoFramework.Hardware.Esp32\" version=\"1.6.34\" targetFramework=\"netnano1.0\" /&gt;\n  &lt;package id=\"nanoFramework.Iot.Device.Ssd13xx\" version=\"1.3.721\" targetFramework=\"netnano1.0\" /&gt;\n  &lt;package id=\"nanoFramework.Runtime.Events\" version=\"1.11.32\" targetFramework=\"netnano1.0\" /&gt;\n  &lt;package id=\"nanoFramework.System.Device.Gpio\" version=\"1.1.57\" targetFramework=\"netnano1.0\" /&gt;\n  &lt;package id=\"nanoFramework.System.Device.I2c\" version=\"1.1.29\" targetFramework=\"netnano1.0\" /&gt;\n  &lt;package id=\"nanoFramework.System.Math\" version=\"1.5.116\" targetFramework=\"netnano1.0\" /&gt;\n&lt;/packages&gt;\nBemærk: I sourcen herunder, refereres også til namespace’et Iot.Device.Ssd13xx.Samples, men det er ikke et assembly eller en NuGet pakke, men derimod defineret i to filer, som ligger med i projektet; BasicFont.cs og DoubleByteFont.cs.\n\n\n\nI demoen initialiseres pin 21 og pin 22, og SSD1306 driveren.\nSelve OLED driveren fungerer sådan at man\n\nrenser displayet (med ClearScreen())\ntegner eller skriver noget på display’et (egentlig tegner “bare” i en buffer)\nHer et f.eks. kald til device.DrawString(2, 2, \"nF IOT!\", 2)\ndet man har tegnet eller skrevet, vises på displayet, ved kald til Display().\n\nBemærk: Det er vigtigt at filerne BasicFont.cs og DoubleByteFont.cs er med, for de definerer namespacet Iot.Device.Ssd13xx.Samples og Class BasicFont og DoubleByteFont. Uden en font kan man ikke skrive tekst og så virker eksemplet ikke.\n// Licensed to the .NET Foundation under one or more agreements.\n// The .NET Foundation licenses this file to you under the MIT license.\n\nusing Iot.Device.Ssd13xx;\nusing Iot.Device.Ssd13xx.Samples;\nusing nanoFramework.Hardware.Esp32;\nusing System.Device.I2c;\nusing System.Diagnostics;\nusing System.Threading;\n\nDebug.WriteLine(\"Hello Ssd1306 Sample!\");\n\n//////////////////////////////////////////////////////////////////////\n// when connecting to an ESP32 device, need to configure the I2C GPIOs\n// used for the bus, for example\nConfiguration.SetPinFunction(21, DeviceFunction.I2C1_DATA);\nConfiguration.SetPinFunction(22, DeviceFunction.I2C1_CLOCK);\n//////////////////////////////////////////////////////////////////////\n\nusing Ssd1306 device = new Ssd1306(\n    I2cDevice.Create(new I2cConnectionSettings(1, Ssd1306.DefaultI2cAddress)), \n    Ssd13xx.DisplayResolution.OLED128x32);\n\ndevice.ClearScreen();\ndevice.Font = new BasicFont();\ndevice.DrawString(2, 2, \"nF IOT!\", 2);//large size 2 font\ndevice.DrawString(2, 32, \"nanoFramework\", 1, true);//centered text\ndevice.Display();\nThread.Sleep(200);\n\ndevice.ClearScreen();\ndevice.Font = new BasicFont();\nfor (int i = 0; i &lt; 50; i++)\n{\n    int line = 1;\n    Debug.WriteLine($\"1, line++, $\\\"i: {i}\\\", 1\");\n    device.Write(1, line++, $\"i: {i}\", 1);\n    device.Write(1, line++, \"Hest!\", 1, true);\n    device.Display();\n    Thread.Sleep(500);\n}\n\nDebug.WriteLine(\"End of Ssd1306 Sample!\");\nThread.Sleep(Timeout.Infinite);\nHele demo-koden findes på https://github.com/s0ren/intro_til-IOT_med-CS/tree/master/OLED_z\nEksemplet er stærkt inspireret af: https://github.com/nanoframework/nanoFramework.IoT.Device/tree/develop/devices/Ssd13xx/samples",
    "crumbs": [
      "Home",
      "Features",
      "Oled display"
    ]
  },
  {
    "objectID": "Features/Oled.html#baggrund",
    "href": "Features/Oled.html#baggrund",
    "title": "Oled display",
    "section": "",
    "text": "TEC har nogle billige “kompatible” OLED displays som er nogenlunde kompatible med AdaFruits tilsvarende. Vi har fået fat i nogen fra producenten DIYmore.\n\nAdaFruits produkt og endnu en udgave af SSD1306\nDe kan altså bruge driverne, som AdaFruit har udviklet til SSD1306, til denne hardware også.\nAdaFruits driver til SSD1306 findes her\nMan kan kigge lidt til Random Nerd Tutorials ESP32 OLED Display with Arduino IDE, som har en vejledning til ESP32, dog med Arduino framework og et 128x64 pixels display.\nMens forbindelserne er næsten de samme. har jeg dog haft hæld med nogle andre pins. Desuden er vores displays 128x32 pixels.",
    "crumbs": [
      "Home",
      "Features",
      "Oled display"
    ]
  },
  {
    "objectID": "Features/Oled.html#c-driver-og-eksempel",
    "href": "Features/Oled.html#c-driver-og-eksempel",
    "title": "Oled display",
    "section": "",
    "text": "For at bruge OLED displayet sammen med nanoFramework og C#, kan vi bruge device-driveren dss13xx, og dette kode eksemplet. For at bekræfte at det virker, har jeg implementeret og afprøvet med … som er i mit egent git repo på GitHub.\nDet der mangler, i de officielle vejledninger er en konkret opstilling, og et billede eller digram af hvor dan det hele forbindes. Man kan let blive i tvivl om hvor mange ben der “bør” være på displayet, og hvor de skal tilsluttes. Det gør at der er mange valg og dermed fejl muligheder.",
    "crumbs": [
      "Home",
      "Features",
      "Oled display"
    ]
  },
  {
    "objectID": "Features/Oled.html#demo-projekt",
    "href": "Features/Oled.html#demo-projekt",
    "title": "Oled display",
    "section": "",
    "text": "frizing med OLED\n\n\n\nTilslutninger\n\n\nESP32-DEVKIT-V1\nOLED display\n\n\n\n\n\nSDA\nD21\nData\n\n\nSCL\nD22\nClock\n\n\nVCC\n3v3\nForsyningsspænding (3,3V)\n\n\nGND\nGND\nJord, stel, nul, minus etc\n\n\n\nJeg vælger at følge kodeeksemplet, og sætte Data og Clock til hhv. D21 og D22. Hvis man kigger på Michanti’s ESP32-DOIT-DEV-KIT-V1, kan man se at port 21 og 22 er markeret lyssebly felter, hvor der står hhv. [SDA] og [SCL]. Desværre stemmer det ikke godt overens med tabellen i nanoFrameworks “ESP32 pinout”?\n\n\n\nMed Project -&gt; Manage Nuget Packages kan du sørge for at det nødvendige pakker er til stede. Du kan også se pakkerne og ders oprindelse i filen packages.config:\n&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;\n&lt;packages&gt;\n  &lt;package id=\"nanoFramework.CoreLibrary\" version=\"1.17.11\" targetFramework=\"netnano1.0\" /&gt;\n  &lt;package id=\"nanoFramework.Hardware.Esp32\" version=\"1.6.34\" targetFramework=\"netnano1.0\" /&gt;\n  &lt;package id=\"nanoFramework.Iot.Device.Ssd13xx\" version=\"1.3.721\" targetFramework=\"netnano1.0\" /&gt;\n  &lt;package id=\"nanoFramework.Runtime.Events\" version=\"1.11.32\" targetFramework=\"netnano1.0\" /&gt;\n  &lt;package id=\"nanoFramework.System.Device.Gpio\" version=\"1.1.57\" targetFramework=\"netnano1.0\" /&gt;\n  &lt;package id=\"nanoFramework.System.Device.I2c\" version=\"1.1.29\" targetFramework=\"netnano1.0\" /&gt;\n  &lt;package id=\"nanoFramework.System.Math\" version=\"1.5.116\" targetFramework=\"netnano1.0\" /&gt;\n&lt;/packages&gt;\nBemærk: I sourcen herunder, refereres også til namespace’et Iot.Device.Ssd13xx.Samples, men det er ikke et assembly eller en NuGet pakke, men derimod defineret i to filer, som ligger med i projektet; BasicFont.cs og DoubleByteFont.cs.\n\n\n\nI demoen initialiseres pin 21 og pin 22, og SSD1306 driveren.\nSelve OLED driveren fungerer sådan at man\n\nrenser displayet (med ClearScreen())\ntegner eller skriver noget på display’et (egentlig tegner “bare” i en buffer)\nHer et f.eks. kald til device.DrawString(2, 2, \"nF IOT!\", 2)\ndet man har tegnet eller skrevet, vises på displayet, ved kald til Display().\n\nBemærk: Det er vigtigt at filerne BasicFont.cs og DoubleByteFont.cs er med, for de definerer namespacet Iot.Device.Ssd13xx.Samples og Class BasicFont og DoubleByteFont. Uden en font kan man ikke skrive tekst og så virker eksemplet ikke.\n// Licensed to the .NET Foundation under one or more agreements.\n// The .NET Foundation licenses this file to you under the MIT license.\n\nusing Iot.Device.Ssd13xx;\nusing Iot.Device.Ssd13xx.Samples;\nusing nanoFramework.Hardware.Esp32;\nusing System.Device.I2c;\nusing System.Diagnostics;\nusing System.Threading;\n\nDebug.WriteLine(\"Hello Ssd1306 Sample!\");\n\n//////////////////////////////////////////////////////////////////////\n// when connecting to an ESP32 device, need to configure the I2C GPIOs\n// used for the bus, for example\nConfiguration.SetPinFunction(21, DeviceFunction.I2C1_DATA);\nConfiguration.SetPinFunction(22, DeviceFunction.I2C1_CLOCK);\n//////////////////////////////////////////////////////////////////////\n\nusing Ssd1306 device = new Ssd1306(\n    I2cDevice.Create(new I2cConnectionSettings(1, Ssd1306.DefaultI2cAddress)), \n    Ssd13xx.DisplayResolution.OLED128x32);\n\ndevice.ClearScreen();\ndevice.Font = new BasicFont();\ndevice.DrawString(2, 2, \"nF IOT!\", 2);//large size 2 font\ndevice.DrawString(2, 32, \"nanoFramework\", 1, true);//centered text\ndevice.Display();\nThread.Sleep(200);\n\ndevice.ClearScreen();\ndevice.Font = new BasicFont();\nfor (int i = 0; i &lt; 50; i++)\n{\n    int line = 1;\n    Debug.WriteLine($\"1, line++, $\\\"i: {i}\\\", 1\");\n    device.Write(1, line++, $\"i: {i}\", 1);\n    device.Write(1, line++, \"Hest!\", 1, true);\n    device.Display();\n    Thread.Sleep(500);\n}\n\nDebug.WriteLine(\"End of Ssd1306 Sample!\");\nThread.Sleep(Timeout.Infinite);\nHele demo-koden findes på https://github.com/s0ren/intro_til-IOT_med-CS/tree/master/OLED_z\nEksemplet er stærkt inspireret af: https://github.com/nanoframework/nanoFramework.IoT.Device/tree/develop/devices/Ssd13xx/samples",
    "crumbs": [
      "Home",
      "Features",
      "Oled display"
    ]
  },
  {
    "objectID": "Features/index.html",
    "href": "Features/index.html",
    "title": "Features",
    "section": "",
    "text": "Her finder du nogle vejledninger af ting som man kan med ESP32 og nanoFramework. Nogle af disse features er indbyggede (f.eks. wifi) andre kræver ekstra eletroniske dimser tilsluttet.\nSe sidebar-menuen.",
    "crumbs": [
      "Home",
      "Features"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "IoT H3",
    "section": "",
    "text": "På Programmeringsspecialet, er IoT faget opdelt så de første to uger er på H3. De næste to uger afvikles på H4.\nVed slutningen af første de, bedømmes eleverne med en delkarakter. Når anden del afsluttes, bedømmes del 1 og del 2 samlet med en standpunktskarakter.\n\n\n\n\n\nArduino\nEsp32\n\nVi bruger ESP32-DEVKIT-V1 [foto]\n\n\n\n\nPå breadboardet kan vi opbygge en konstruktion med både CPU og Sensorer og Aktustorer\nFor at få plads til det udviklingsbord vi råder over, skal vi bruge en speciel konstruktion med to (2) breadborads som er sat sammen. På den måde kan vi forbinde til benene begge sider af udviklingsborded.\n[billede] \n\n\n\n\nHvad en sensor og en aktuator er…\n\n\n\nSom noget helt nyt, skal vi prøve at lave forløbet, på en måde hvor vi programmerer i C#!\nDet har nogen åbenlyse fordele, i læringsprocessen, at det ikke er nødvendigt at skifte programmeringssprog. Samtidig går vi glib af nyttig læring ved netop at lære et et nyt sprog (c++ eller python). Desuden er der en risiko for at frameworket ikke understøtter de funktionaliteter vi skal bruge for at lave en fornuftig IoT løsning.\nI dette forløb bruger vi nanoFramework.\nSe vejledningen her viser hvor og hvordan man installerer deres extension til Visual Studio.\nI vejledninger er der nogle trin som beskriver hvor dan man lægger et nyt firmware image på IoT enheden. Dette trin har jeg klaret, så der allerede nanoFrameworks firmware på dimserne. __I behøver altså ikke installere nanoff og opdatere firmware__. Det kan vi muligvis komme tilbage til, men bliver sikkert ikke nødvendigt.\nDer er også en udviddelse til Visual Studio Code, men med mindre support.\n\n\n\n\nSouce kode til visse øvelser ligger på https://github.com/s0ren/intro_til-IOT_med-CS\n\n\nDen første øvelse går ud på at oprette et projekt til nanoFramework og afvikle default skabelonen. Et lille program, som skriver en tekst i Debug vinduet.\nDu skal montere ESP32 DEVKIT V1 udviklingsboardet på et dobbelt breadboar som vist her:\n\nNår du opretter projektet, skulle der gerne være en program.cs med dette:\nusing System;\nusing System.Diagnostics;\nusing System.Threading;\n\nnamespace hejsa\n{\n    public class Program\n    {\n        public static void Main()\n        {\n            Debug.WriteLine(\"Hello from nanoFramework!\");\n\n            Thread.Sleep(Timeout.Infinite);\n        }\n    }\n}\n\n\n\nOpret et ny project, i samme solution ved at højreklikke på din solution (øverst i Solution Explorer), vælg Add og New Project.., sørg for at templaten er Blank Application (.NET nanoFramework).\nHer skal programmet få den indbyggede LED på ESP32’eren til at blinke. Derfor er der ikke brug for at ændre opstillingen på breadboardet. Bare brug den samme opstilling som ovenfor.\nSørg for at denne kode fungerer:\nusing System;\nusing System.Diagnostics;\nusing System.Threading;\nusing System.Device.Gpio;\n\n\nnamespace Blink1\n{\n    public class Program\n    {\n        public static void Main()\n        {\n            Debug.WriteLine(\"Hello from nanoFramework!\");\n\n            int PinNumber = 2;\n            GpioPin bultinLED = new GpioController().OpenPin(PinNumber, PinMode.Output);\n            \n            while (true)\n            {\n                // Turn on the LED (assuming an active high configuration)\n                bultinLED.Write(PinValue.High);\n                Thread.Sleep(500); // Keep the LED on for 500 milliseconds\n                \n                // Turn off the LED\n                bultinLED.Write(PinValue.Low);\n                Thread.Sleep(500); // Keep the LED off for 500 milliseconds\n            }\n\n            Thread.Sleep(Timeout.Infinite);\n        }\n    }\n}\nBemærk at koden også gør brug af namespacet System.Device.Gpio. Dette findes i en pakke fra nanoFramework som skal tilføjes til projektet.\n\nHøjre-klik på dit projekt\nvælg Manage NuGet Packages…\n\nVælg Browse\nSøg evt på nanoFramework.sys\ntryk Install\n\n\n\n\nHer skal vi bygge på breadboardet.\n\nDet nye er at:\n\nder skal være en LED på breadbordet, som skal styres fra boarded.\nLED’en skal beskyttes mod overspænding med en modstand på 220 ohm.\nDen positive side af LED’en, det ben der er længst, skal forbindes til pin 18 (via modstanden)\nLED’ens andet ben skal forbindes til stel. På engelsk Ground eller GND.\n\nProgramkoden er næsten den samme, blot er PinNumber sat til at være 18 i stedet for 2:\nusing System;\nusing System.Device.Gpio;\nusing System.Diagnostics;\nusing System.Threading;\n\nnamespace Blink2_pin18\n{\n    public class Program\n    {\n        public static void Main()\n        {\n            Debug.WriteLine(\"Hello from nanoFramework! With police blink blink\");\n\n            int PinNumber = 18;\n            GpioPin bultinLED = new GpioController().OpenPin(PinNumber, PinMode.Output);\n            \n            while (true)\n            {\n                \n                // Turn on the LED (assuming an active high configuration)\n                bultinLED.Write(PinValue.High);\n                Thread.Sleep(500); // Keep the LED on for 500 milliseconds\n\n                // Turn off the LED\n                bultinLED.Write(PinValue.Low);\n                Thread.Sleep(500); // Keep the LED off for 500 milliseconds\n            }\n        }\n    }\n}"
  },
  {
    "objectID": "index.html#introduktion",
    "href": "index.html#introduktion",
    "title": "IoT H3",
    "section": "",
    "text": "Arduino\nEsp32\n\nVi bruger ESP32-DEVKIT-V1 [foto]\n\n\n\n\nPå breadboardet kan vi opbygge en konstruktion med både CPU og Sensorer og Aktustorer\nFor at få plads til det udviklingsbord vi råder over, skal vi bruge en speciel konstruktion med to (2) breadborads som er sat sammen. På den måde kan vi forbinde til benene begge sider af udviklingsborded.\n[billede] \n\n\n\n\nHvad en sensor og en aktuator er…\n\n\n\nSom noget helt nyt, skal vi prøve at lave forløbet, på en måde hvor vi programmerer i C#!\nDet har nogen åbenlyse fordele, i læringsprocessen, at det ikke er nødvendigt at skifte programmeringssprog. Samtidig går vi glib af nyttig læring ved netop at lære et et nyt sprog (c++ eller python). Desuden er der en risiko for at frameworket ikke understøtter de funktionaliteter vi skal bruge for at lave en fornuftig IoT løsning.\nI dette forløb bruger vi nanoFramework.\nSe vejledningen her viser hvor og hvordan man installerer deres extension til Visual Studio.\nI vejledninger er der nogle trin som beskriver hvor dan man lægger et nyt firmware image på IoT enheden. Dette trin har jeg klaret, så der allerede nanoFrameworks firmware på dimserne. __I behøver altså ikke installere nanoff og opdatere firmware__. Det kan vi muligvis komme tilbage til, men bliver sikkert ikke nødvendigt.\nDer er også en udviddelse til Visual Studio Code, men med mindre support."
  },
  {
    "objectID": "index.html#øvelser",
    "href": "index.html#øvelser",
    "title": "IoT H3",
    "section": "",
    "text": "Souce kode til visse øvelser ligger på https://github.com/s0ren/intro_til-IOT_med-CS\n\n\nDen første øvelse går ud på at oprette et projekt til nanoFramework og afvikle default skabelonen. Et lille program, som skriver en tekst i Debug vinduet.\nDu skal montere ESP32 DEVKIT V1 udviklingsboardet på et dobbelt breadboar som vist her:\n\nNår du opretter projektet, skulle der gerne være en program.cs med dette:\nusing System;\nusing System.Diagnostics;\nusing System.Threading;\n\nnamespace hejsa\n{\n    public class Program\n    {\n        public static void Main()\n        {\n            Debug.WriteLine(\"Hello from nanoFramework!\");\n\n            Thread.Sleep(Timeout.Infinite);\n        }\n    }\n}\n\n\n\nOpret et ny project, i samme solution ved at højreklikke på din solution (øverst i Solution Explorer), vælg Add og New Project.., sørg for at templaten er Blank Application (.NET nanoFramework).\nHer skal programmet få den indbyggede LED på ESP32’eren til at blinke. Derfor er der ikke brug for at ændre opstillingen på breadboardet. Bare brug den samme opstilling som ovenfor.\nSørg for at denne kode fungerer:\nusing System;\nusing System.Diagnostics;\nusing System.Threading;\nusing System.Device.Gpio;\n\n\nnamespace Blink1\n{\n    public class Program\n    {\n        public static void Main()\n        {\n            Debug.WriteLine(\"Hello from nanoFramework!\");\n\n            int PinNumber = 2;\n            GpioPin bultinLED = new GpioController().OpenPin(PinNumber, PinMode.Output);\n            \n            while (true)\n            {\n                // Turn on the LED (assuming an active high configuration)\n                bultinLED.Write(PinValue.High);\n                Thread.Sleep(500); // Keep the LED on for 500 milliseconds\n                \n                // Turn off the LED\n                bultinLED.Write(PinValue.Low);\n                Thread.Sleep(500); // Keep the LED off for 500 milliseconds\n            }\n\n            Thread.Sleep(Timeout.Infinite);\n        }\n    }\n}\nBemærk at koden også gør brug af namespacet System.Device.Gpio. Dette findes i en pakke fra nanoFramework som skal tilføjes til projektet.\n\nHøjre-klik på dit projekt\nvælg Manage NuGet Packages…\n\nVælg Browse\nSøg evt på nanoFramework.sys\ntryk Install\n\n\n\n\nHer skal vi bygge på breadboardet.\n\nDet nye er at:\n\nder skal være en LED på breadbordet, som skal styres fra boarded.\nLED’en skal beskyttes mod overspænding med en modstand på 220 ohm.\nDen positive side af LED’en, det ben der er længst, skal forbindes til pin 18 (via modstanden)\nLED’ens andet ben skal forbindes til stel. På engelsk Ground eller GND.\n\nProgramkoden er næsten den samme, blot er PinNumber sat til at være 18 i stedet for 2:\nusing System;\nusing System.Device.Gpio;\nusing System.Diagnostics;\nusing System.Threading;\n\nnamespace Blink2_pin18\n{\n    public class Program\n    {\n        public static void Main()\n        {\n            Debug.WriteLine(\"Hello from nanoFramework! With police blink blink\");\n\n            int PinNumber = 18;\n            GpioPin bultinLED = new GpioController().OpenPin(PinNumber, PinMode.Output);\n            \n            while (true)\n            {\n                \n                // Turn on the LED (assuming an active high configuration)\n                bultinLED.Write(PinValue.High);\n                Thread.Sleep(500); // Keep the LED on for 500 milliseconds\n\n                // Turn off the LED\n                bultinLED.Write(PinValue.Low);\n                Thread.Sleep(500); // Keep the LED off for 500 milliseconds\n            }\n        }\n    }\n}"
  },
  {
    "objectID": "projektopgave/index.html",
    "href": "projektopgave/index.html",
    "title": "Projektopgave",
    "section": "",
    "text": "Opgaven er at lave et apparat som fungerer som termostat-konsol (“Termostat” 2024).",
    "crumbs": [
      "Home",
      "Projektopgave"
    ]
  },
  {
    "objectID": "projektopgave/index.html#lignende-produkter-på-markedet",
    "href": "projektopgave/index.html#lignende-produkter-på-markedet",
    "title": "Projektopgave",
    "section": "1 Lignende produkter på markedet",
    "text": "1 Lignende produkter på markedet\nDer findes allerede en del pudukter på markedet, både industrielle og til homeautomation. Her er et par eksempler:\n\n\n\n\n\n\n\n\n\n\n\n(Netatmo 2025)\n(Tado 2025)\n\n\n\nDu behøver slet ikke implemetere alle features som de kommercielle produkter har.",
    "crumbs": [
      "Home",
      "Projektopgave"
    ]
  },
  {
    "objectID": "projektopgave/index.html#sec-opbygning_og_virkemåde",
    "href": "projektopgave/index.html#sec-opbygning_og_virkemåde",
    "title": "Projektopgave",
    "section": "2 Opbygning og virkemåde",
    "text": "2 Opbygning og virkemåde\n\n2.1 Fysisk opbygning\nApparatet skal have en fast tilsluttet temperatursensor. Her vil jeg anbefale DS18b20. Apparatet skal have et fysisk bruger interface bestående af et OLED display et antal lysdioder. Til at modtage instrukser fra brugeren, skal apparatet nogle knapper. deuden skal apparatet bruge sit indbyggede wifi til web interface og data-afrapportering.\n\nen ESP32\nen temepratursensor (DS18B20)\net OLED display (128x32 pixels)\ntre lysdioder (rød, grøn og blå)\ntre knapper\net sammensat breadbord (med plads til en ESP32)\nsmå jumper ledninger, passende antal og farver\nmodstande, 220 ohm til lysdioder, 4,7 k ohm til pulldown på knapper\n\n\n\n2.2 Virkemåde\nTemperatursensoren måler temepraturen i lokalet, med passende tidsinterval.\nDen målte temperatur findes syndsynligvis som værdien i en variabel, men det er også nødvendigt at gemme temperatur-målingerne, så apparatet har en historik over tidligere målinger.\nDe historiske data dels skal bruges til at lave web-grafen (Se Sektion 4) . Og til at overføre til en datalogger via internettet (se Sektion 6).\nDet er nødvendigt at gemme de målte temperaturer, en et tidsstempel (hvornår temperaturen er målt), på det indbyggede filsystem. Det er sikkert også smart at gemme oplysninger om systemets ovrige status, samtidig (f.eks. ønsket temperatur … etc)\nPå OLED displayet skal både vises\n\nden aktuelle temperatur, målt med den tilsluttede temperatursensor.\n\nDesuden skal OLED displayet vise\n\nden ønskede temperatur. Altså det termostaten er indstillet til.\n\nog et display hvor man kan se den aktuelle temeperatur, og den ønskede temperatur, som er forindstillet.\nTo af kanpperne skal bruges til at brugeren kan forhøje den ønskede temperatur, eller sænke den.\nEn knap markeres med + så den bruges til at øge ønsket temperatur. Hver gang der trykkes på knappen, øges med et trin.\nEn anden knap markeres med -og bruges til at sænke tempereturen, lige som +, bare nedad.\nOvervej (og beskriv) hvor stort et trin instilligen skal skifte med for hvert trýk. Skal det være 0,1 grad, 0,5 1,0 eller hvad giver mening. Noter en faglig fornuftigt vurdering. Skift eventuelt mening efter afprøvning, og overvej sammenhængen med toleranceværdien for hvornår apparatet går i varme-og køle-tilstand.\nLysdioderne skal markere:\n\nrød lyser når temperaturen er under den ønskede, og en fiktiv varmekilde er i gang\ngrøn lyser når temperaturren er OK\nblå lyser når temperaturen er under det ønskede, og et fiktivt kølesystem er i gang.\n\nHer skal der være en global værdi for en telerance-margien, som gør at den rød og blå først aktiveres når temperaturen er hhv. et stykke under og et stykke over den ønskede forvalgte temperatur.\nDen sidste knap, skal bruges til reset og wakeup. Se afsnittet Net konfiguration Sektion 5.\nNår brugeren trykker i et antal sekunder du vælger (f.eks. 10 sekunder), kan man starte AP-setup-mode, på apparatet. Se næste afsnit.\nDet er nyttigt hvis netværksfunktionerne er gået i udu, eller man bare ved at der skal skiftes indstillinger.\nNår brugeren trykker kortvarigt, vækkes apparatet, hvis det har været i deep-sleep. Så vil de normale web-funktioner være tilgængeligt i antal minutter. Du vælger hvor mange minutter. Under test er et kortere tidrum nyttigt, så det er lettere at afprøve uden for lange ventetider, med med tid nok til at afprøve funktionalitet..",
    "crumbs": [
      "Home",
      "Projektopgave"
    ]
  },
  {
    "objectID": "projektopgave/index.html#sec-Web_kontrolpanel",
    "href": "projektopgave/index.html#sec-Web_kontrolpanel",
    "title": "Projektopgave",
    "section": "3 Web kontrolpanel",
    "text": "3 Web kontrolpanel\n\n\n\nWeb kontrolpanel\n\n\nNår apparatet er i normal drift, skal det køre en webside, med de samme indstillingsmuligheder som på det fysiske apparat.\nDer skal vises\n\nden aktuelle temeperatur\nden ønskde teperatur\nUI-elementer (prikker eller lign) der ligner og har sammenfunktion som lysdioderne på apparatet (rød, grøn, blå)\nKnapper for + og -.\nlink til grafsiden\ndesuden en knap eller link til at skifte til Net konfiguration\nmåske også en mulighed for at udsætte deep-sleep?\n\nBemærk: De sidste to elementer er ikke med på skitsen ovenfor.",
    "crumbs": [
      "Home",
      "Projektopgave"
    ]
  },
  {
    "objectID": "projektopgave/index.html#sec-Web_graf",
    "href": "projektopgave/index.html#sec-Web_graf",
    "title": "Projektopgave",
    "section": "4 Web graf",
    "text": "4 Web graf\n\n\n\nWeb graf\n\n\nPå denne side vises en graf over temperaturer.\n\nBrugeren kan skifte mellem visning af døgn, uge eller måned.\nEt døgn regnes fra midnat til midnat, eller fra midnat til nu.\nEn uge regnes fra mandag kl 00.00 til søndag kl 23.50.\nEn måned er fra den første til sidste dag i måneden.\nBrugeren kan bladre tilbage, i dage uger, og måneder.\n\nBemærk: Det kan være nødvendigt at udstyre apparatet med genererede demo-data, for at afprøve og demonstrere bladring.",
    "crumbs": [
      "Home",
      "Projektopgave"
    ]
  },
  {
    "objectID": "projektopgave/index.html#sec-Web_Net_konfiguration",
    "href": "projektopgave/index.html#sec-Web_Net_konfiguration",
    "title": "Projektopgave",
    "section": "5 Web Net konfiguration",
    "text": "5 Web Net konfiguration\n\n\n\nweb netconfig\n\n\nNår apparatet skal installeres hos en kunde, og vi forestiller os at det pakkes ud fra æsken, har det ingen gyldige indstillinger for hvilket WiFi netværk der skal anvendes.\nDerfor skal apparatet starte i en tilstand hvor apparatet selv fungerer som et WiFi accesspoint (AP-mode). Operatøren, eller brugeren, hvis det er samme person, kan tilslutte en enhed (mobil, tablet, PC eller anden computer), og browse ind på en side hvor det er muligt at indstille oplysninger, som\n\nWiFi SSID\n\nWiFi password/nøgle\n\nUrl på datalogger\n\nbrugernavn på dataloggeren\npassword på dataloggeren\n\nog en UI-knap til at gemme oplysningerne\n\nNår indstillingerne er gemt på apparatet, genstartes det med de nye indstillinger.\nHvis apparatet ikke kan opnå forbindelse til det WiFi SSID, som er angivet, inden for at skykke tid (f.eks. 30 sekunder. Beskriv og begrund), går apparatet tilbage til AP-mode og viser konfigurationssiden.\nEllers, hvis apparatet forbindes til WiFi, vises den tildelte ip-adresse på OLED displayet i et stykke tid (beskriv og begrund).\nPå denne side skal operatøren ogsa have mulighed for at indstille\n\nurl til datalogger\n\nbrugernavn på datalogger\npassword på datalogger.\n\n\nDisse skal også gemmes til senerebrug. Evt i en fil på det indbyggede filsystem.",
    "crumbs": [
      "Home",
      "Projektopgave"
    ]
  },
  {
    "objectID": "projektopgave/index.html#sec-datalogning",
    "href": "projektopgave/index.html#sec-datalogning",
    "title": "Projektopgave",
    "section": "6 Datalogning",
    "text": "6 Datalogning\n\n\n\nDatalogning\n\n\nDatalogning er at gemme historiske data. Logning af data skal foregå lokalt, på filsystemet, og til en server vi en internet forbindelse.\nDet er vigtigt for datakvaliteten, at apparatet gemmer data lokalt, så det er måligt at overføre manglende data, hvis serveren er utilgængelig i perioder. Når forbindelsen til serveren er tilbage, kan de data som ikke blev overført, sendes til serveren. Apparatet skal altså have en funktionalitet til at registrere, hvilke data, som er overført, og hvilker som ikke er.\nHistoriske data er ikke data fra forrige århundrede eller de puniske krige, men bare data der er et par minutter gamle. Eller fra i går, i forregårs eller en uge gamle eller en måned gamle.\nFordi vi ikke målinger fra tidpunkter tidligere end starten på projektet, kommer du nok til at opfinde nogen, vi kan se det hele fungere. Det siger sig selv (håber jeg), at sådan nogen historiske data vi bruger under udviklingen, ikke skal distribueres med i et endeligt produkt. Kan du håndtere en forskel på det?\nDet er meget IoT’ish at bruge en Message Brooker som f.eks. (= en server som understøtter MQTT-protokollen). Men det kan være et REST-API eller en direkte forbindelse til en relationsdatabse eller så et S3 filobjekt på skyen. Eller … du kan sikker finde mange flere muligheder.\nSå snart vores egen MQTT-server er i drift, kan du benytte den.",
    "crumbs": [
      "Home",
      "Projektopgave"
    ]
  },
  {
    "objectID": "projektopgave/index.html#sec-Dokumentation",
    "href": "projektopgave/index.html#sec-Dokumentation",
    "title": "Projektopgave",
    "section": "7 Dokumentation",
    "text": "7 Dokumentation\nTil projektopgaven hører noget dokumentation.\nDu skal lave to brugervejledninger, men ikke en fuld rapport.\nDen ene er en vejledning til slutbrugeren, den anden er en vejledning til den person der skal opsætte og installere apparatet.\n\n7.1 Slutbrugervejledning\nSlutbrugeren kunne f.eks. være min mor, hvis hun havde fået det her apparat sat op der hjemme.\nHun skal forstå hvad hun kan se på displayet, og trykke på det to knapper, + og -.\nEventuelt også på hendes smartphone. Min mor har ikke en smartphone, men det har min far, han kan bare ikke finde ud af at bruge den :-)\nDenne vejledning fylder en halv til en hel side. Der må gerne være et billede, så slutbrugeren kan se hvad der er der forklares.\n\n\n7.2 Operatørvejledning\nDer skal også være en vejledning til operatøren. Det er den person som pakker apparatet ud, og installerer det på netværket. Der skal være en forklaring på hvordan netværk konfigureres og hvad konfigurationsoplysningerne gør.\nDer skal også være et fritzing-diagram som viser opbygningen, enten med fritzing (Gonmei 2025) eller et alternativ, f.eks. wokwi (Wokwi 2025).\nDesuden skal der være en forklaring på hvilke data som overføres til dataloggeren.",
    "crumbs": [
      "Home",
      "Projektopgave"
    ]
  }
]