[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "IoT H3",
    "section": "",
    "text": "På Programmeringsspecialet, er IoT faget opdelt så de første to uger er på H3. De næste to uger afvikles på H4.\nVed slutningen af første de, bedømmes eleverne med en delkarakter. Når anden del afsluttes, bedømmes del 1 og del 2 samlet med en standpunktskarakter.\n\n\n\n\n\nArduino\nEsp32\n\nVi bruger ESP32-DEVKIT-V1 [foto]\n\n\n\n\nPå breadboardet kan vi opbygge en konstruktion med både CPU og Sensorer og Aktustorer\nFor at få plads til det udviklingsbord vi råder over, skal vi bruge en speciel konstruktion med to (2) breadborads som er sat sammen. På den måde kan vi forbinde til benene begge sider af udviklingsborded.\n[billede] \n\n\n\n\nHvad en sensor og en aktuator er…\n\n\n\nSom noget helt nyt, skal vi prøve at lave forløbet, på en måde hvor vi programmerer i C#!\nDet har nogen åbenlyse fordele, i læringsprocessen, at det ikke er nødvendigt at skifte programmeringssprog. Samtidig går vi glib af nyttig læring ved netop at lære et et nyt sprog (c++ eller python). Desuden er der en risiko for at frameworket ikke understøtter de funktionaliteter vi skal bruge for at lave en fornuftig IoT løsning.\nI dette forløb bruger vi nanoFramework.\nSe vejledningen her viser hvor og hvordan man installerer deres extension til Visual Studio.\nI vejledninger er der nogle trin som beskriver hvor dan man lægger et nyt firmware image på IoT enheden. Dette trin har jeg klaret, så der allerede nanoFrameworks firmware på dimserne. __I behøver altså ikke installere nanoff og opdatere firmware__. Det kan vi muligvis komme tilbage til, men bliver sikkert ikke nødvendigt.\nDer er også en udviddelse til Visual Studio Code, men med mindre support.\n\n\n\n\nSouce kode til visse øvelser ligger på https://github.com/s0ren/intro_til-IOT_med-CS\n\n\nDen første øvelse går ud på at oprette et projekt til nanoFramework og afvikle default skabelonen. Et lille program, som skriver en tekst i Debug vinduet.\nDu skal montere ESP32 DEVKIT V1 udviklingsboardet på et dobbelt breadboar som vist her:\n\nNår du opretter projektet, skulle der gerne være en program.cs med dette:\nusing System;\nusing System.Diagnostics;\nusing System.Threading;\n\nnamespace hejsa\n{\n    public class Program\n    {\n        public static void Main()\n        {\n            Debug.WriteLine(\"Hello from nanoFramework!\");\n\n            Thread.Sleep(Timeout.Infinite);\n        }\n    }\n}\n\n\n\nOpret et ny project, i samme solution ved at højreklikke på din solution (øverst i Solution Explorer), vælg Add og New Project.., sørg for at templaten er Blank Application (.NET nanoFramework).\nHer skal programmet få den indbyggede LED på ESP32’eren til at blinke. Derfor er der ikke brug for at ændre opstillingen på breadboardet. Bare brug den samme opstilling som ovenfor.\nSørg for at denne kode fungerer:\nusing System;\nusing System.Diagnostics;\nusing System.Threading;\nusing System.Device.Gpio;\n\n\nnamespace Blink1\n{\n    public class Program\n    {\n        public static void Main()\n        {\n            Debug.WriteLine(\"Hello from nanoFramework!\");\n\n            int PinNumber = 2;\n            GpioPin bultinLED = new GpioController().OpenPin(PinNumber, PinMode.Output);\n            \n            while (true)\n            {\n                // Turn on the LED (assuming an active high configuration)\n                bultinLED.Write(PinValue.High);\n                Thread.Sleep(500); // Keep the LED on for 500 milliseconds\n                \n                // Turn off the LED\n                bultinLED.Write(PinValue.Low);\n                Thread.Sleep(500); // Keep the LED off for 500 milliseconds\n            }\n\n            Thread.Sleep(Timeout.Infinite);\n        }\n    }\n}\nBemærk at koden også gør brug af namespacet System.Device.Gpio. Dette findes i en pakke fra nanoFramework som skal tilføjes til projektet.\n\nHøjre-klik på dit projekt\nvælg Manage NuGet Packages…\n\nVælg Browse\nSøg evt på nanoFramework.sys\ntryk Install\n\n\n\n\nHer skal vi bygge på breadboardet.\n\nDet nye er at:\n\nder skal være en LED på breadbordet, som skal styres fra boarded.\nLED’en skal beskyttes mod overspænding med en modstand på 220 ohm.\nDen positive side af LED’en, det ben der er længst, skal forbindes til pin 18 (via modstanden)\nLED’ens andet ben skal forbindes til stel. På engelsk Ground eller GND.\n\nProgramkoden er næsten den samme, blot er PinNumber sat til at være 18 i stedet for 2:\nusing System;\nusing System.Device.Gpio;\nusing System.Diagnostics;\nusing System.Threading;\n\nnamespace Blink2_pin18\n{\n    public class Program\n    {\n        public static void Main()\n        {\n            Debug.WriteLine(\"Hello from nanoFramework! With police blink blink\");\n\n            int PinNumber = 18;\n            GpioPin bultinLED = new GpioController().OpenPin(PinNumber, PinMode.Output);\n            \n            while (true)\n            {\n                \n                // Turn on the LED (assuming an active high configuration)\n                bultinLED.Write(PinValue.High);\n                Thread.Sleep(500); // Keep the LED on for 500 milliseconds\n\n                // Turn off the LED\n                bultinLED.Write(PinValue.Low);\n                Thread.Sleep(500); // Keep the LED off for 500 milliseconds\n            }\n        }\n    }\n}"
  },
  {
    "objectID": "index.html#introduktion",
    "href": "index.html#introduktion",
    "title": "IoT H3",
    "section": "",
    "text": "Arduino\nEsp32\n\nVi bruger ESP32-DEVKIT-V1 [foto]\n\n\n\n\nPå breadboardet kan vi opbygge en konstruktion med både CPU og Sensorer og Aktustorer\nFor at få plads til det udviklingsbord vi råder over, skal vi bruge en speciel konstruktion med to (2) breadborads som er sat sammen. På den måde kan vi forbinde til benene begge sider af udviklingsborded.\n[billede] \n\n\n\n\nHvad en sensor og en aktuator er…\n\n\n\nSom noget helt nyt, skal vi prøve at lave forløbet, på en måde hvor vi programmerer i C#!\nDet har nogen åbenlyse fordele, i læringsprocessen, at det ikke er nødvendigt at skifte programmeringssprog. Samtidig går vi glib af nyttig læring ved netop at lære et et nyt sprog (c++ eller python). Desuden er der en risiko for at frameworket ikke understøtter de funktionaliteter vi skal bruge for at lave en fornuftig IoT løsning.\nI dette forløb bruger vi nanoFramework.\nSe vejledningen her viser hvor og hvordan man installerer deres extension til Visual Studio.\nI vejledninger er der nogle trin som beskriver hvor dan man lægger et nyt firmware image på IoT enheden. Dette trin har jeg klaret, så der allerede nanoFrameworks firmware på dimserne. __I behøver altså ikke installere nanoff og opdatere firmware__. Det kan vi muligvis komme tilbage til, men bliver sikkert ikke nødvendigt.\nDer er også en udviddelse til Visual Studio Code, men med mindre support."
  },
  {
    "objectID": "index.html#øvelser",
    "href": "index.html#øvelser",
    "title": "IoT H3",
    "section": "",
    "text": "Souce kode til visse øvelser ligger på https://github.com/s0ren/intro_til-IOT_med-CS\n\n\nDen første øvelse går ud på at oprette et projekt til nanoFramework og afvikle default skabelonen. Et lille program, som skriver en tekst i Debug vinduet.\nDu skal montere ESP32 DEVKIT V1 udviklingsboardet på et dobbelt breadboar som vist her:\n\nNår du opretter projektet, skulle der gerne være en program.cs med dette:\nusing System;\nusing System.Diagnostics;\nusing System.Threading;\n\nnamespace hejsa\n{\n    public class Program\n    {\n        public static void Main()\n        {\n            Debug.WriteLine(\"Hello from nanoFramework!\");\n\n            Thread.Sleep(Timeout.Infinite);\n        }\n    }\n}\n\n\n\nOpret et ny project, i samme solution ved at højreklikke på din solution (øverst i Solution Explorer), vælg Add og New Project.., sørg for at templaten er Blank Application (.NET nanoFramework).\nHer skal programmet få den indbyggede LED på ESP32’eren til at blinke. Derfor er der ikke brug for at ændre opstillingen på breadboardet. Bare brug den samme opstilling som ovenfor.\nSørg for at denne kode fungerer:\nusing System;\nusing System.Diagnostics;\nusing System.Threading;\nusing System.Device.Gpio;\n\n\nnamespace Blink1\n{\n    public class Program\n    {\n        public static void Main()\n        {\n            Debug.WriteLine(\"Hello from nanoFramework!\");\n\n            int PinNumber = 2;\n            GpioPin bultinLED = new GpioController().OpenPin(PinNumber, PinMode.Output);\n            \n            while (true)\n            {\n                // Turn on the LED (assuming an active high configuration)\n                bultinLED.Write(PinValue.High);\n                Thread.Sleep(500); // Keep the LED on for 500 milliseconds\n                \n                // Turn off the LED\n                bultinLED.Write(PinValue.Low);\n                Thread.Sleep(500); // Keep the LED off for 500 milliseconds\n            }\n\n            Thread.Sleep(Timeout.Infinite);\n        }\n    }\n}\nBemærk at koden også gør brug af namespacet System.Device.Gpio. Dette findes i en pakke fra nanoFramework som skal tilføjes til projektet.\n\nHøjre-klik på dit projekt\nvælg Manage NuGet Packages…\n\nVælg Browse\nSøg evt på nanoFramework.sys\ntryk Install\n\n\n\n\nHer skal vi bygge på breadboardet.\n\nDet nye er at:\n\nder skal være en LED på breadbordet, som skal styres fra boarded.\nLED’en skal beskyttes mod overspænding med en modstand på 220 ohm.\nDen positive side af LED’en, det ben der er længst, skal forbindes til pin 18 (via modstanden)\nLED’ens andet ben skal forbindes til stel. På engelsk Ground eller GND.\n\nProgramkoden er næsten den samme, blot er PinNumber sat til at være 18 i stedet for 2:\nusing System;\nusing System.Device.Gpio;\nusing System.Diagnostics;\nusing System.Threading;\n\nnamespace Blink2_pin18\n{\n    public class Program\n    {\n        public static void Main()\n        {\n            Debug.WriteLine(\"Hello from nanoFramework! With police blink blink\");\n\n            int PinNumber = 18;\n            GpioPin bultinLED = new GpioController().OpenPin(PinNumber, PinMode.Output);\n            \n            while (true)\n            {\n                \n                // Turn on the LED (assuming an active high configuration)\n                bultinLED.Write(PinValue.High);\n                Thread.Sleep(500); // Keep the LED on for 500 milliseconds\n\n                // Turn off the LED\n                bultinLED.Write(PinValue.Low);\n                Thread.Sleep(500); // Keep the LED off for 500 milliseconds\n            }\n        }\n    }\n}"
  },
  {
    "objectID": "Features/index.html",
    "href": "Features/index.html",
    "title": "Features",
    "section": "",
    "text": "Her finder du nogle vejledninger af ting som man kan med ESP32 og nanoFramework. Nogle af disse features er indbyggede (f.eks. wifi) andre kræver ekstra eletroniske dimser tilsluttet.\nSe sidebar-menuen.",
    "crumbs": [
      "Home",
      "Features"
    ]
  },
  {
    "objectID": "Features/Oled.html",
    "href": "Features/Oled.html",
    "title": "Oled display",
    "section": "",
    "text": "Video\nvideo demo\n\n\n\n\nTEC har nogle billige “kompatible” OLED displays som er nogenlunde kompatible med AdaFruits tilsvarende. Vi har fået fat i nogen fra producenten DIYmore.\n\nAdaFruits produkt og endnu en udgave af SSD1306\nDe kan altså bruge driverne, som AdaFruit har udviklet til SSD1306, til denne hardware også.\nAdaFruits driver til SSD1306 findes her\nMan kan kigge lidt til Random Nerd Tutorials ESP32 OLED Display with Arduino IDE, som har en vejledning til ESP32, dog med Arduino framework og et 128x64 pixels display.\nMens forbindelserne er næsten de samme. har jeg dog haft hæld med nogle andre pins. Desuden er vores displays 128x32 pixels.\n\n\n\n\nFor at bruge OLED displayet sammen med nanoFramework og C#, kan vi bruge device-driveren dss13xx, og dette kode eksemplet. For at bekræfte at det virker, har jeg implementeret og afprøvet med … som er i mit egent git repo på GitHub.\nDet der mangler, i de officielle vejledninger er en konkret opstilling, og et billede eller digram af hvor dan det hele forbindes. Man kan let blive i tvivl om hvor mange ben der “bør” være på displayet, og hvor de skal tilsluttes. Det gør at der er mange valg og dermed fejl muligheder.\n\n\n\n\n\n\n\n\nfrizing med OLED\n\n\n\nTilslutninger\n\n\nESP32-DEVKIT-V1\nOLED display\n\n\n\n\n\nSDA\nD21\nData\n\n\nSCL\nD22\nClock\n\n\nVCC\n3v3\nForsyningsspænding (3,3V)\n\n\nGND\nGND\nJord, stel, nul, minus etc\n\n\n\nJeg vælger at følge kodeeksemplet, og sætte Data og Clock til hhv. D21 og D22. Hvis man kigger på Michanti’s ESP32-DOIT-DEV-KIT-V1, kan man se at port 21 og 22 er markeret lyssebly felter, hvor der står hhv. [SDA] og [SCL]. Desværre stemmer det ikke godt overens med tabellen i nanoFrameworks “ESP32 pinout”?\n\n\n\nMed Project -&gt; Manage Nuget Packages kan du sørge for at det nødvendige pakker er til stede. Du kan også se pakkerne og ders oprindelse i filen packages.config:\n&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;\n&lt;packages&gt;\n  &lt;package id=\"nanoFramework.CoreLibrary\" version=\"1.17.11\" targetFramework=\"netnano1.0\" /&gt;\n  &lt;package id=\"nanoFramework.Hardware.Esp32\" version=\"1.6.34\" targetFramework=\"netnano1.0\" /&gt;\n  &lt;package id=\"nanoFramework.Iot.Device.Ssd13xx\" version=\"1.3.721\" targetFramework=\"netnano1.0\" /&gt;\n  &lt;package id=\"nanoFramework.Runtime.Events\" version=\"1.11.32\" targetFramework=\"netnano1.0\" /&gt;\n  &lt;package id=\"nanoFramework.System.Device.Gpio\" version=\"1.1.57\" targetFramework=\"netnano1.0\" /&gt;\n  &lt;package id=\"nanoFramework.System.Device.I2c\" version=\"1.1.29\" targetFramework=\"netnano1.0\" /&gt;\n  &lt;package id=\"nanoFramework.System.Math\" version=\"1.5.116\" targetFramework=\"netnano1.0\" /&gt;\n&lt;/packages&gt;\nBemærk: I sourcen herunder, refereres også til namespace’et Iot.Device.Ssd13xx.Samples, men det er ikke et assembly eller en NuGet pakke, men derimod defineret i to filer, som ligger med i projektet; BasicFont.cs og DoubleByteFont.cs.\n\n\n\nI demoen initialiseres pin 21 og pin 22, og SSD1306 driveren.\nSelve OLED driveren fungerer sådan at man\n\nrenser displayet (med ClearScreen())\ntegner eller skriver noget på display’et (egentlig tegner “bare” i en buffer)\nHer et f.eks. kald til device.DrawString(2, 2, \"nF IOT!\", 2)\ndet man har tegnet eller skrevet, vises på displayet, ved kald til Display().\n\nBemærk: Det er vigtigt at filerne BasicFont.cs og DoubleByteFont.cs er med, for de definerer namespacet Iot.Device.Ssd13xx.Samples og Class BasicFont og DoubleByteFont. Uden en font kan man ikke skrive tekst og så virker eksemplet ikke.\n// Licensed to the .NET Foundation under one or more agreements.\n// The .NET Foundation licenses this file to you under the MIT license.\n\nusing Iot.Device.Ssd13xx;\nusing Iot.Device.Ssd13xx.Samples;\nusing nanoFramework.Hardware.Esp32;\nusing System.Device.I2c;\nusing System.Diagnostics;\nusing System.Threading;\n\nDebug.WriteLine(\"Hello Ssd1306 Sample!\");\n\n//////////////////////////////////////////////////////////////////////\n// when connecting to an ESP32 device, need to configure the I2C GPIOs\n// used for the bus, for example\nConfiguration.SetPinFunction(21, DeviceFunction.I2C1_DATA);\nConfiguration.SetPinFunction(22, DeviceFunction.I2C1_CLOCK);\n//////////////////////////////////////////////////////////////////////\n\nusing Ssd1306 device = new Ssd1306(\n    I2cDevice.Create(new I2cConnectionSettings(1, Ssd1306.DefaultI2cAddress)), \n    Ssd13xx.DisplayResolution.OLED128x32);\n\ndevice.ClearScreen();\ndevice.Font = new BasicFont();\ndevice.DrawString(2, 2, \"nF IOT!\", 2);//large size 2 font\ndevice.DrawString(2, 32, \"nanoFramework\", 1, true);//centered text\ndevice.Display();\nThread.Sleep(200);\n\ndevice.ClearScreen();\ndevice.Font = new BasicFont();\nfor (int i = 0; i &lt; 50; i++)\n{\n    int line = 1;\n    Debug.WriteLine($\"1, line++, $\\\"i: {i}\\\", 1\");\n    device.Write(1, line++, $\"i: {i}\", 1);\n    device.Write(1, line++, \"Hest!\", 1, true);\n    device.Display();\n    Thread.Sleep(500);\n}\n\nDebug.WriteLine(\"End of Ssd1306 Sample!\");\nThread.Sleep(Timeout.Infinite);\nHele demo-koden findes på https://github.com/s0ren/intro_til-IOT_med-CS/tree/master/OLED_z\nEksemplet er stærkt inspireret af: https://github.com/nanoframework/nanoFramework.IoT.Device/tree/develop/devices/Ssd13xx/samples",
    "crumbs": [
      "Home",
      "Features",
      "Oled display"
    ]
  },
  {
    "objectID": "Features/Oled.html#baggrund",
    "href": "Features/Oled.html#baggrund",
    "title": "Oled display",
    "section": "",
    "text": "TEC har nogle billige “kompatible” OLED displays som er nogenlunde kompatible med AdaFruits tilsvarende. Vi har fået fat i nogen fra producenten DIYmore.\n\nAdaFruits produkt og endnu en udgave af SSD1306\nDe kan altså bruge driverne, som AdaFruit har udviklet til SSD1306, til denne hardware også.\nAdaFruits driver til SSD1306 findes her\nMan kan kigge lidt til Random Nerd Tutorials ESP32 OLED Display with Arduino IDE, som har en vejledning til ESP32, dog med Arduino framework og et 128x64 pixels display.\nMens forbindelserne er næsten de samme. har jeg dog haft hæld med nogle andre pins. Desuden er vores displays 128x32 pixels.",
    "crumbs": [
      "Home",
      "Features",
      "Oled display"
    ]
  },
  {
    "objectID": "Features/Oled.html#c-driver-og-eksempel",
    "href": "Features/Oled.html#c-driver-og-eksempel",
    "title": "Oled display",
    "section": "",
    "text": "For at bruge OLED displayet sammen med nanoFramework og C#, kan vi bruge device-driveren dss13xx, og dette kode eksemplet. For at bekræfte at det virker, har jeg implementeret og afprøvet med … som er i mit egent git repo på GitHub.\nDet der mangler, i de officielle vejledninger er en konkret opstilling, og et billede eller digram af hvor dan det hele forbindes. Man kan let blive i tvivl om hvor mange ben der “bør” være på displayet, og hvor de skal tilsluttes. Det gør at der er mange valg og dermed fejl muligheder.",
    "crumbs": [
      "Home",
      "Features",
      "Oled display"
    ]
  },
  {
    "objectID": "Features/Oled.html#demo-projekt",
    "href": "Features/Oled.html#demo-projekt",
    "title": "Oled display",
    "section": "",
    "text": "frizing med OLED\n\n\n\nTilslutninger\n\n\nESP32-DEVKIT-V1\nOLED display\n\n\n\n\n\nSDA\nD21\nData\n\n\nSCL\nD22\nClock\n\n\nVCC\n3v3\nForsyningsspænding (3,3V)\n\n\nGND\nGND\nJord, stel, nul, minus etc\n\n\n\nJeg vælger at følge kodeeksemplet, og sætte Data og Clock til hhv. D21 og D22. Hvis man kigger på Michanti’s ESP32-DOIT-DEV-KIT-V1, kan man se at port 21 og 22 er markeret lyssebly felter, hvor der står hhv. [SDA] og [SCL]. Desværre stemmer det ikke godt overens med tabellen i nanoFrameworks “ESP32 pinout”?\n\n\n\nMed Project -&gt; Manage Nuget Packages kan du sørge for at det nødvendige pakker er til stede. Du kan også se pakkerne og ders oprindelse i filen packages.config:\n&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;\n&lt;packages&gt;\n  &lt;package id=\"nanoFramework.CoreLibrary\" version=\"1.17.11\" targetFramework=\"netnano1.0\" /&gt;\n  &lt;package id=\"nanoFramework.Hardware.Esp32\" version=\"1.6.34\" targetFramework=\"netnano1.0\" /&gt;\n  &lt;package id=\"nanoFramework.Iot.Device.Ssd13xx\" version=\"1.3.721\" targetFramework=\"netnano1.0\" /&gt;\n  &lt;package id=\"nanoFramework.Runtime.Events\" version=\"1.11.32\" targetFramework=\"netnano1.0\" /&gt;\n  &lt;package id=\"nanoFramework.System.Device.Gpio\" version=\"1.1.57\" targetFramework=\"netnano1.0\" /&gt;\n  &lt;package id=\"nanoFramework.System.Device.I2c\" version=\"1.1.29\" targetFramework=\"netnano1.0\" /&gt;\n  &lt;package id=\"nanoFramework.System.Math\" version=\"1.5.116\" targetFramework=\"netnano1.0\" /&gt;\n&lt;/packages&gt;\nBemærk: I sourcen herunder, refereres også til namespace’et Iot.Device.Ssd13xx.Samples, men det er ikke et assembly eller en NuGet pakke, men derimod defineret i to filer, som ligger med i projektet; BasicFont.cs og DoubleByteFont.cs.\n\n\n\nI demoen initialiseres pin 21 og pin 22, og SSD1306 driveren.\nSelve OLED driveren fungerer sådan at man\n\nrenser displayet (med ClearScreen())\ntegner eller skriver noget på display’et (egentlig tegner “bare” i en buffer)\nHer et f.eks. kald til device.DrawString(2, 2, \"nF IOT!\", 2)\ndet man har tegnet eller skrevet, vises på displayet, ved kald til Display().\n\nBemærk: Det er vigtigt at filerne BasicFont.cs og DoubleByteFont.cs er med, for de definerer namespacet Iot.Device.Ssd13xx.Samples og Class BasicFont og DoubleByteFont. Uden en font kan man ikke skrive tekst og så virker eksemplet ikke.\n// Licensed to the .NET Foundation under one or more agreements.\n// The .NET Foundation licenses this file to you under the MIT license.\n\nusing Iot.Device.Ssd13xx;\nusing Iot.Device.Ssd13xx.Samples;\nusing nanoFramework.Hardware.Esp32;\nusing System.Device.I2c;\nusing System.Diagnostics;\nusing System.Threading;\n\nDebug.WriteLine(\"Hello Ssd1306 Sample!\");\n\n//////////////////////////////////////////////////////////////////////\n// when connecting to an ESP32 device, need to configure the I2C GPIOs\n// used for the bus, for example\nConfiguration.SetPinFunction(21, DeviceFunction.I2C1_DATA);\nConfiguration.SetPinFunction(22, DeviceFunction.I2C1_CLOCK);\n//////////////////////////////////////////////////////////////////////\n\nusing Ssd1306 device = new Ssd1306(\n    I2cDevice.Create(new I2cConnectionSettings(1, Ssd1306.DefaultI2cAddress)), \n    Ssd13xx.DisplayResolution.OLED128x32);\n\ndevice.ClearScreen();\ndevice.Font = new BasicFont();\ndevice.DrawString(2, 2, \"nF IOT!\", 2);//large size 2 font\ndevice.DrawString(2, 32, \"nanoFramework\", 1, true);//centered text\ndevice.Display();\nThread.Sleep(200);\n\ndevice.ClearScreen();\ndevice.Font = new BasicFont();\nfor (int i = 0; i &lt; 50; i++)\n{\n    int line = 1;\n    Debug.WriteLine($\"1, line++, $\\\"i: {i}\\\", 1\");\n    device.Write(1, line++, $\"i: {i}\", 1);\n    device.Write(1, line++, \"Hest!\", 1, true);\n    device.Display();\n    Thread.Sleep(500);\n}\n\nDebug.WriteLine(\"End of Ssd1306 Sample!\");\nThread.Sleep(Timeout.Infinite);\nHele demo-koden findes på https://github.com/s0ren/intro_til-IOT_med-CS/tree/master/OLED_z\nEksemplet er stærkt inspireret af: https://github.com/nanoframework/nanoFramework.IoT.Device/tree/develop/devices/Ssd13xx/samples",
    "crumbs": [
      "Home",
      "Features",
      "Oled display"
    ]
  }
]